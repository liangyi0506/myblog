# Java面试八股文

# Java面试八股文

## 一. Java基础

1. #### Java语言有哪些特点

   - Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。
   - 具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。
   - Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。
   - Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。
   - Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。

2. #### Java文件中可以有多个类吗（不包含内部类）

   一个Java文件中可以有多个类，但是最多只能有一个被public修饰的类；

   如果该文件中包含public修饰的类，则类的名称和Java文件的名称必须相同。

3. #### Java访问权限

   Java语言中共有三种访问修饰符：public、private、protected；
   在使用这些修饰符修饰目标时，一共可以形成四种访问权限，public、private、protected、default（不加任何修饰符）。

   1. 修饰成员变量/方法时：
      private：该成员可以被该类内部成员访问；
      default：该成员可以被该类内部成员访问，也可以被同一包下的其他类访问；
      protected：该成员可以被该类内部成员访问，也可以被同一包下的其他类访问，还可以被它的子类访问；
      public：该成员可以被任意类访问。
   2. 修饰类时：
      default：该类可以被同一包下的其他类访问；
      public： 该类可以被任意包下，任意类访问

4. #### Java数据类型

   1. Java数据类型包括两大类：基本数据类型，引用数据类型。
   2. 基本数据类型有8个，可以分为4类：整数类型（byte/short/int/long）、浮点类型（float/double）、字符类型（char）、布尔类型（boolean）。除了布尔类型，其他都可以看作为数组类型，可以进行类型转换。
   3. 引用类型就是对一个对象的引用，根据引用对象的不同，可以分为数组、类、接口引用类型。实质上就是通过指针，指向堆中对象所持有的内存空间。
   4. 基本数据类型所占的内存空间
      - byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1；
      - short：2字节（16位），数据范围是 -2^15 ~ 2^15-1；
      - int：4字节（32位），数据范围是 -2^31 ~ 2^31-1；
      - long：8字节（64位），数据范围是 -2^63 ~ 2^63-1；
      - float：4字节（32位），数据范围是 -3.4*10^38 ~ 3.4*10^38；
      - double：8字节（64位），数据范围是 -1.8*10^308 ~ 1.8*10^308；
      - char：2字节（16位），数据范围是 \u0000 ~ \uffff；
      - boolean：不同的JVM有不同的实现机制，没有固定的参数

5. #### Java内部类

   - 成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性。
   - 局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。
   - 匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量。
   - 静态内部类：类似类的静态成员变量。

6. #### Java为什么不支持多重继承

   为了程序的结构能够更加清晰从而便于维护。假设 Java 语言支持多重继承，类 C 继承自类 A 和类 B，如果类 A 和 B 都有自定义的成员方法 `f()`，那么当代码中调用类 C 的 `f()` 会产生二义性。

   Java 语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类 C 继承接口 A 与接口 B 时即使它们都有方法`f()`，也不能直接调用方法，需实现具体的`f()`方法才能调用，不会产生二义性。

   多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。

7. Java代码块执行顺序

   - 父类静态代码块（只执行一次）
   - 子类静态代码块（只执行一次）
   - 父类构造代码块
   - 父类构造函数
   - 子类构造代码块
   - 子类构造函数
   - 普通代码块

8. #### 全局变量(成员变量)和局部变量

   Java中没有全局变量，这是c语言中的概念，Java中对应的名称叫做成员变量。

   1. 成员变量

      成员变量是在类的范围内定义的变量；

      成员变量有默认初始值；

      未被static修饰的成员变量也叫实例变量，存储于对象所在的堆内存当中，生命周期与对象相同；

      被static修饰的成员变量也叫类变量，存储于方法区当中，生命周期与当前类相同

   2. 局部变量

      局部变量是在方法内定义的变量；

      局部变量没有默认初始值；

      局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。

9. 

10. #### 为什么要有包装类

   ​		Java是面向对象的语言，设计理念就是“一切皆是对象”。但是8种基本数据类型却不属于对象，为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，叫做包装类。

   自动装箱与自动拆箱是JDK1.5提供的功能。

   自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；
   自动拆箱：可以把一个包装类型的数据直接赋值给对应额基本类型；
   应用场景：例如某个方法的参数是包装类型，调用时我们所使用的数据却是基本类型的数据，这时可以不做任何处理，直接将这个基本类型的值传入给方法即可

11. #### 面向对象的理解

    1. 什么是面向对象？

       > java将对象视为一种奇特的变量，它除了可以存储数据之外还可以对它自身进行操作。它能够直接反映现实生活中的事物，例如人、车、小鸟等，将其表示为程序中的对象。每个对象都具有各自的状态特征（也可以称为属性）及行为特征（方法），**java就是通过对象之间行为的交互来解决问题的**

    2. 面向对象和面向过程的区别？

       **面向过程**

       优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。
       缺点：不易维护、不易复用、不易扩展

       **面向对象**

       优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
       缺点：性能比面向过程差

    3. Java面向对象的三大特性？

       类具有三个特性：封装、继承和多态。

       **[1、封装(Encapsulation)](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV18J411W7cE%3Fp%3D111)**

       封转是指属性私有化

       - 根据需要提供setter和getter方法来访问属性
       - 隐藏具体属性和实现细节，仅对外开放接口
       - 控制程序中属性的访问级别

       目的：增强数据安全性，不能让其他用户随意访问和修改数据，简化编程，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员

       **[2、继承（Extend）](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV18J411W7cE%3Fp%3D150)**

       继承是指将多个相同的属性和方法提取出来，新建一个父类

       - java中一个类只能继承一个父类，且只能继承访问权限非private属性和方法
       - 子类可以重写父类中的方法，命名与父类中同名的属性

       目的：代码复用

       **[3、多态](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV18J411W7cE%3Fp%3D169)**

       多态（Polymiorph）可以分为两种：设计时多态、运行时多态

       - **设计（编译）时多态：**即重载（Overload），是指java允许方法名相同而参数不同（返回值可以相同也可以不同），同一个类中允许存在一个或多个以上的同名函数，只要参数类型或参数个数不同即可
       - **运行时多态：**即重写（Override）必须是在继承体系中，子类重写父类方法，JVM运行时根据调用该方法的类型决定调用那个方法

       目的：增加代码的灵活度

12. #### 重载和重写的区别

    **重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

    **重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。

13. #### Object常用的方法

    - hashCode：通过对象计算出的散列码。用于 map 型或 equals 方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。
    - equals：判断两个对象是否一致。需保证 equals 方法相同对应的对象 hashCode 也相同。
    - toString: 用字符串表示该对象
    - clone:深拷贝一个对象

14. #### hashCode() 和 equals()的关系

    1. hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数

    2. 以“HashSet如何检查重复”为例子来说明为什么要有hashCode：

       对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有 值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来 检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。

    3. 如果两个对象相等，那么hashcode一定相等，且equals()返回true，但是如果两个对象有相同的hashcode，两者不一定相等，hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashCode(),那么class的两个对象（具有相同的内容）无论如何也不会相等

15. #### 为什么要把String设计为不可变

    - **节省空间**：字符串常量存储在 JVM 的字符串池中可以被用户共享。
    - **提高效率**：String 可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。
    - **安全**：String 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。

16. #### ==和equal是比较

    ==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址

    equals：object中默认也是采用==比较，通常会重写Object

17. #### String，StringBuffer，StringBuilder的区别

    1. String，采用final修饰，值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间
    2.  StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量，且线程安全 
    3. StringBuilder可变类，速度更快，但是线程不安全
    4. 推荐修改字符串时，多线程下使用StringBuffer，单线程下使用StringBuilder

18. #### 接口和抽象类的区别

    1. 抽象类可以存在普通成员函数，而接口中只能存在public abstract 方法。
    2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。
    3. 抽象类只能继承一个，接口可以实现多个。

    **接口的设计目的**，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有 什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无， 但不对如何实现行为进行限制。

    **而抽象类的设计目的**，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实 现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己 实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。

    **抽象类是对类本质的抽象**，表达的是 is a 的关系，比如： BMW is a Car 。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。

    **而接口是对行为的抽象**，表达的是 like a 的关系。比如： Bird like a Aircraft （像飞行器一样可以飞），但其本质上 is a Bird 。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

    **使用场景**：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

    **抽象类的功能要远超过接口，但是，定义抽象类的代价高**。因为高级语言来说（从实际设计上来说也 是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功 能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计 阶段会降低难度

19. #### Java异常的分类

    Java 异常分为 Error（程序无法处理的错误），和 Exception（程序本身可以处理的异常）。这两个类均继承 Throwable。

    Error 常见的有 StackOverFlowError、OutOfMemoryError 等等。

    Exception 可分为运行时异常和非运行时异常。对于运行时异常，可以利用 try catch 的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。

20. #### Java怎么处理异常

    Exception 可分为运行时异常和非运行时异常。对于运行时异常，可以利用 try catch 的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。

21. #### throw和throws的区别

    throw 一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。

    throws 一般用于方法声明上，代表该方法可能会抛出的异常列表。

22. #### **出现在 Java 程序中的 finally 代码块是否一定会执行？**

    当遇到下面情况不会执行。

    - 当程序在进入 try 语句块之前就出现异常时会直接结束。
    - 当程序在 try 块中强制退出时，如使用 System.exit(0)，也不会执行 finally 块中的代码。

    其它情况下，在 try/catch/finally 语句执行的时候，try 块先执行，当有异常发生，catch 和 finally 进行处理后程序就结束了，当没有异常发生，在执行完 finally 中的代码后，后面代码会继续执行。值得注意的是，当 try/catch 语句块中有 return 时，finally 语句块中的代码会在 return 之前执行。如果 try/catch/finally 块中都有 return 语句，finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句。

23. #### **final、finally 和 finalize 的区别是什么？**

    - final 用于声明属性、方法和类，分别表示属性不可变、方法不可重写覆盖、类不可继承。
    - finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。
    - finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用 finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存

24. #### static关键字

    **static 的主要作用有两个**：

    - 为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。
    - 使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。

    **具体而言 static 又可分为 4 种使用方式**：

    - **修饰成员变量**。用 static 关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用“类.静态变量”和“对象.静态变量”的方法使用。
    - **修饰成员方法**。static 修饰的方法无需创建对象就可以被调用。static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态成员变量和静态成员方法。
    - **修饰代码块**。JVM 在加载类的时候会执行 static 代码块。static 代码块常用于初始化静态变量。static 代码块只会被执行一次。
    - **修饰内部类**。static 内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。

25. #### final关键字

    1. 修饰类：表示类不可被继承

    2. 修饰方法：表示方法不可被子类覆盖重写，但是可以重载

    3. 修饰变量：表示变量一旦被赋值就不可以更改它的值。

       （1） 修饰成员变量

       - 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。
       - 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。

       （2） 修饰局部变量

       系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时， 即可以在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码 中对final变量赋初值（仅一次）

       （3） 修饰基本类型数据和引用类型数据

       - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；
       - 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。**但是引用指向的内容是可变的**。

26. #### 泛型

    1. 什么是泛型

       1. Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
       2. **泛型的本质是参数化类型**，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法

    2. 为什么使用泛型

       泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率

       1. **保证了类型的安全性**，在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。
       2. **消除了强制转换**，这使得代码更加可读，并且减少了出错机会。
       3. **避免了不一样的装箱，拆箱操作，提高了程序的性能**，泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。

    3. 泛型擦除

       Java 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理时被擦除，这个过程被称为泛型擦除。

27. #### 注解

    1. 简述注解

       Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。

       其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。

    2. 简述元注解

       元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：

       - @Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM 中运行）。
       - @Target：表示注解作用的范围。
       - @Documented：将注解中的元素包含到 Javadoc 中去。
       - @Inherited：一个被@Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。
       - @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。

28. #### 序列化（串行化）和反序列化（并行化）

    **序列化**，也叫**串行化**，就是把内存中的对象转换为字节序列(二进制流),这些二进制流既可以写入文件, 实现了持久化; 还可以通过网络传输给其他JVM使用,为分布式应用(RMI Remote Method Invocation)提供支持。

    **反序列化**，也叫**并行化**，把字节序列(二进制流)恢复为对象的过程称为对象的[反序列化]

    **具体实现**：实现 Serializable 接口，或实现 Externalizable 接口中的 writeExternal()与 readExternal()方法。

29. #### 简述JDK-JVM-JRE

    1. JVM（Java Virtual Machine）
       Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，其目的就是使用相同的字节码，这样会给出相同的结果。字节码和不同系统的JVM是实现Java语言跨平台的关键。

       JVM并不是只有一种！只要满足JVM规范，每个公司、组织，甚至个人都可以开发自己的JVM，我们平时接触到的HotSpot JVM仅仅是JVM规范中的一种实现。

    2. JDK（Java Development Kit）
       JDK是功能齐全的SDK，拥有JRE的全部内容，还有编译器（javac）和工具（如javadoc和jdb），能够创建和编译Java程序。

    3. JRE（Java Runtime Environment）
       JRE是Java运行时环境，它是运行和编译Java程序所需的所有内容的集合，包括Java虚拟机，Java类库，Java命令和其他的一些基础构建，但是不能用于创建新程序。

    JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK

20. #### List和Set的区别

    1. List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出 所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素，主要有ArrayList和LinkedList两种实现
    2. Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元 素，在逐一遍历各个元素，主要有HashSet，LinkedHashSet，TreeSet三种shixian

21. #### Java中线程安全的基本数据结构有哪些？

    - HashTable: 哈希表的线程安全版，效率低
    - ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代 HashTable
    - Vector：线程安全版 Arraylist
    - Stack：线程安全版栈
    - BlockingQueue 及其子类：线程安全版队列

22. #### **ArrayList和LinkedList区别**

    **ArrayList：**基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固 定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会 涉及到元素的移动（往后复制一份，插入新元素），使用尾插法并指定初始容量可以极大提升性能、甚 至超过linkedList（需要创建大量的node对象）

    **LinkedList：**基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历

    遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需 要对list重新进行遍历，性能消耗极大。

    另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。

23. #### **HashMap和HashTable有什么区别？其底层实现是什么？**

    1. 区别 ：

    （1） HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；

    （2） HashMap允许key和value为null，而HashTable不允许

    （3）Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现

    2. 联系

    （1）HashMap时Hashtable的轻量级实现（非线程安全的实现），他们都实现了Map接口

    3. 底层实现：数组+链表实现

       jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在

    （1）计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，

    （2）如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，

    （3）如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表		高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表

    （4）key为null，存在下标0的位置

24. #### NIO和IO的区别

    IO是面向流的，NIO是面向缓冲区的
    Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；
    NIO则能前后移动流中的数据，因为是面向缓冲区的
    IO流是阻塞的，NIO流是不阻塞的
    Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了
    Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
    选择器
    Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道

25. #### NIO**的优势**

    1. 优势在于一个线程管理多个通道；但是数据的处理将会变得复杂；
    2. 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，采用这种

26. #### IO的优势

    1. 适用于一个线程管理一个通道的情况；因为其中的流数据的读取是阻塞的；
    2. 如果需要管理同时打开不太多的连接，这些连接会发送大量的数据；

## 二. Spring

1. #### Spring是什么

   ​		Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转(IoC)和面向切面(AOP)。

   ​		简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。

2. ## Spring常用注解

   1. @Component：标注一个普通的Spring Bean类。 
   2. @Controller：标注一个控制器组件类。 
   3. @Service：标注一个业务层组件类。 
   4. @Repository：标注一个dao持久层组件类。

3. #### Spring用了哪些设计模式

   BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式

4. #### Spring事务原理

   ​		spring事务有编程式和声明式，我们一般使用声明式，在某个方法上增加@Transactional注解，这个方法中的sql会统一成功或失败。

   **原理是：**

   ​		当一个方法加上@Transactional注解，spring会基于这个类生成一个代理对象并将这个代理对象作为bean，当使用这个bean中的方法时，如果存在@Transactional注解，就会将事务自动提交设为false，然后执行方法，执行过程没有异常则提交，有异常则回滚、

5. #### Spring事务失效场景

   （1）事务方法所在的类没有加载到容器中

   （2）事务方法不是public类型

   （3）同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效

   （4）spring事务默认只回滚运行时异常，可以用rollbackfor属性设置

   （5）业务自己捕获了异常，事务会认为程序正常秩序

6. #### Spring事务的隔离级别

   default:默认级别，使用数据库自定义的隔离级别

   其它四种隔离级别与mysql

7. #### Spring事务的传播行为

   （1）支持当前事务，如果不存在，则新启一个事务

   （2）支持当前事务，如果不存在，则抛出异常

   （3）支持当前事务，如果不存在，则以非事务方式执行

   （4）不支持当前事务，创建一个新事物

   （5）不支持当前事务，如果已存在事务就抛异常

   （6）不支持当前事务，始终以非事务方式执行

8. #### Spring中IOC（控制反转）的理解

   ​		IOC容器：实际上就是一个map（key，value），里面存着各种对象（在xml里配置的bean节点、@repository、@Service、@controller、@component），在项目启动的时候回读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里

   ​		这个时候map里面就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过ID注入（@autowired，@resource等注解，xml里bean结点内的ref属性，项目启动的时候就会读取xml节点ref属性，根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。

   **控制反转**：

   没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。

   引入IOC容器之后，对象A与对象B之间失去了失去了直接联系，当对象A运行到需要对象B的时候，IOC会主动创建一个对象B注入到对象A需要的地方。

   通过前后的对比，不难看出：对象A获得依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒过来了，这句是“控制反转”这个名称的由来

   全部对象的控制权全部上缴给第三方“IOC”容器，所以，IOC容器成了整个系统的关键核心，它气到了一种类似粘合剂的所用，把系统中的所有对象粘合在一起发挥作用，如果没有这个粘合剂，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成粘合剂的由来

   **依赖注入：**

   获得依赖对象的过程被反转了。控制被反转之后，获得依赖对象的过程由自身管理变成了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。

9. #### 如何实现一个IOC容器

   1.配置文件，配置包扫描路径

   2.递归包，扫描获取.class文件

   3.反射、确定需要交给IOC管理的类

   4.对需要注入的类进行依赖注入

   - 配置文件中指定需要扫描的包路径
   - 配置一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解
   - 从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储
   - 遍历这个Set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象
   - 遍历这个IOC容器,获取到每一个类的实例,判断里面是有否有依赖其它的类的实例,然后进行递归注入

10. #### Spring中AOP（面向切面）的理解

    ​		系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志，事务管理和信息安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。

    ​		当我们需要为分散的对象引入公共行为的时候，OOP显得无能为力。也就是说OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。

    ​		日志代码往往水平散布在所有对象层次中，而与它所散布到的随想的核心功能毫无关系。

    ​		在OOP设置中，它导致了大量代码的重复，而不利于各个模块的重用。

    ​		AOP：将程序的交互业务逻辑（如安全、日志、事务），封装成一个切面，然后注入的到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外地做一些事情，在某个方法执行之后额外做一些事情。

11. #### SpringMVC工作原理

    ​		SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）

    **工作流程：**

    （1）DispatchServerlet接收用户请求将请求发送给HandleMapping

    （2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet

    （3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler

    （4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view

    （5）DispatchServerlet根据view进行视图渲染，返回给用户

12. SpringMVC常用注解

    1. **@Controller** 声明该类为SpringMVC中的Controller

       控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中使用@Controller ，就无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。

       @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式

    2. **@RequestMapping**

       1. @RequestMapping的作用是建立请求URL和处理方法之间的对应关系

       2. @RequestMapping可以作用在方法和类上

          > 作用在类上：第一级的访问目录
          > 作用在方法上：第二级的访问目录

    3. **@Autowired**

       1. 作用：spring可以自动帮你把bean里面引用的对象的setter/getter方法省略，它会自动帮你set/get
       2. 正常情况下，你在userService里面要做一个userDao的setter/getter方法，但如果你用了@Autowired，你就不需要写getter/setter方法了，只需要在UserService的实现类中声明即可，之所以不用写，秘诀就在于java的“反射机制”

    4. **@ResponseBody**

       1. **作用：**@ResponseBody注解通常使用在控制层的方法上，用于将Controller的方法返回的对象，通过springmvc提供的`HttpMessageConverter`接口转换为指定格式的数据如：json、xml等，通过Response响应给客户端。假如是字符串则直接将字符串写到客户端；假如是一个对象，此时会将对象转化为json串然后写到客户端。这里需要注意的是，如果返回对象，按utf-8编码。如果返回String，页面可能出现乱码。因此在注解中我们可以手动修改编码格式，

    5. **@RequestBody**

       1. **作用：**用于获取请求体的内容
          RequestBody 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 JSON 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 @RequestBody 接收会非常方便

13. #### SpringBoot的自动配置原理

    启动类@SpringbootApplication注解下，有三个关键注解

    （1）@springbootConfiguration:表示启动类是一个自动配置类

    （2）@CompontScan:扫描启动类所在包外的组件到容器中

    （3）@EnableConfigutarion:最关键的一个注解，他拥有两个子注解，其中@AutoConfigurationpackageu会将启动类所在包下的所有组件到容器中，@Import会导入一个自动配置文件选择器，他会去加载META_INF目录下的spring.factories文件，这个文件中存放很大自动配置类的全类名，这些类会根据元注解的装配条件生效，生效的类就会被实例化，加载到ioc容器中

14. #### SpringBoot常用注解

    @RestController ：修饰类，该控制器会返回Json数据

    @RequestMapping("/path") ：修饰类，该控制器的请求路径

    @Autowired : 修饰属性，按照类型进行依赖注入

    @PathVariable : 修饰参数，将路径值映射到参数上

    @ResponseBody :修饰方法，该方法会返回Json数据

    @RequestBody（需要使用Post提交方式） :修饰参数，将Json数据封装到对应参数中

    @Controller@Service@Compont: 将类注册到ioc容器

15. #### SpringMVC和SpringBoot的区别

    pring boot只是一个配置工具,整合工具,辅助工具.

    springmvc是框架,项目中实际运行的代码

    **Spring 框架**就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的ioc和 aop，ioc 提供了依赖注入的容器， aop解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。

    **Spring MVC提供了一种轻度耦合的方式来开发web应用。**它是Spring的一个模块，是一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。

    **Spring Boot实现了自动配置，降低了项目搭建的复杂度**。它主要是为了解决使用Spring框架需要进行大量的配置太麻烦的问题，所以它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)。

    Spring Boot只是承载者，辅助你简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。

    对使用者来说，换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。

     

    **总结：**Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。

     

    所以，用最简练的语言概括就是：

    Spring 是一个“引擎”；

    Spring MVC 是基于Spring的一个 MVC 框架；

    Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。

## 三. Redis

1. #### redis为什么快

   （1）完全基于内存操作，数据都存在内存中

   （2）采用单线程，避免了不必要的上下文切换带来的性能问题，也不用考虑锁的问题

   （3）基于非阻塞的io多路复用机制

   （4）数据结构简单，对数据操作简单

2. #### redis持久化机制

   （1）快照持久化RDB

   ​		redis的默认持久化机制，通过父进程fork一个子进程，子进程将redis的数据快照写入一个临时文件，等待持久化完毕后替换上一次的rdb文件。整个过程主进程不进行任何的io操作。持久化策略可以通过save配置单位时间内执行多少次操作触发持久化。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，缺点是可能会丢失两次持久化之间的数据

   （2）追加持久化AOF

   ​		以日志形式记录每一次的写入和删除操作，策略有每秒同步、每次操作同步、不同步，优点是数据完整性高，缺点是运行效率低，恢复时间长

3. #### redis如何实现key的过期删除

   定期过期+惰性过期

   **定期删除** ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。

   **惰性删除** ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。

4. #### redis数据类型

   String 常用命令： set,get,decr,incr,mget等

   Hash 常用命令： hget,hset,hgetall 等

   List 常用命令： lpush,rpush,lpop,rpop,lrange 等

   Set 常用命令： sadd,spop,smembers,sunion 等

   SortSet 常用命令： zadd,zrange,zrem,zcard 等

5. #### redis缓存穿透如何解决

   **缓存穿透是指**频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。

   **解决方案**：

   （1）在接口上做基础校验，比如id<=0就拦截

   （2）缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致

   （3）布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求

6. #### redis缓存击穿如何解决

   **缓存击穿是指**一个key非常热点，key在某一瞬间失效，导致大量请求到达数据库

   **解决方案**：

   （1）设置热点数据永不过期

   （2）给缓存重建的业务加上互斥锁，缺点是性能低

7. #### redis缓存雪崩如何解决

   **缓存雪崩是指**某一时间Key同时失效或redis宕机，导致大量请求到达数据库

   **解决方案：**

   （1）搭建集群保证高可用

   （2）进行数据预热，给不同的key设置随机的过期时间

   （3）给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量

   （4）给业务添加多级缓

8. #### redis分布式锁的实现原理

   ​	原理是使用setnx+setex命令来实现，但是会有一系列问题：

   （1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决

   （2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作

   （3）不可重入。可以使用Redision解决（实现机制类似AQS,计数）

   （4）redis集群下主节点宕机导致锁丢失。使用红锁解决

9. #### redis集群方案

   **(1)主从模式**：个master节点，多个slave节点，master节点宕机slave自动变成主节点

   **(2)哨兵模式**：在主从集群基础上添加哨兵节点或哨兵集群，用于监控master节点健康状态，通过投票机制选择slave成为主节点

   **(3)分片集群**：主从模式和哨兵模式解决了并发读的问题，但没有解决并发写的问题，因此有了分片集群。分片集群有多个master节点并且不同master保存不同的数据，master之间通过ping相互监测健康状态。客户端请求任意一个节点都会转发到正确节点，因为每个master都被映射到0-16384个插槽上，集群的key是根据key的hash值与插槽绑定

10. #### redis集群主从同步原理

    ​		主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。

    ​		后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据

11. #### redis缓存一致性解决方案

    ​		更新数据库时把缓存给删除是最优方案，可以更大概率避免并发问题，但是依旧会有缓存删除失败的问题。可以使用分布式事务，或者在删除失败后把key发送到rabbitMQ中进行异步删除重试

## 四. 计算机网络

1. #### TCP协议

   TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。

2. #### TCP协议的特点

   1. 面向连接

      ​	面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

   2. 仅支持单播传输

      每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。

   3. 面向字节流

      TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。

   4. 可靠传输

      对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

   5. 拥有拥塞控制

      当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞

3. #### TCP三次握手连接过程

    第一次握手

           客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

   第二次握手

           服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

   第三次握手

           当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

4. #### 为什么需要三次握手

      为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误

5. #### TCP四次握手断开连接过程

   第一次握手

           若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

   第二次握手

           B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

   第三次握手

           B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

   第四次握手

           A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。
   
6. #### UDP协议

     UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

   **它有以下特点：**

   1. 面向无连接

   首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

   具体来说就是：

   在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
   在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
   2. 有单播，多播，广播的功能

           UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

   3. UDP是面向报文的

           发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文

   4. 不可靠性

           首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
           
           并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。
           
           再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

   5. 头部开销小，传输报文是高效的

7. #### TCP和UDP的区别

   - TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。
   - 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
   - 对数据准确性要求高，速度可以相对较慢的，可以选用TCP

## 四. 操作系统

## 五. 数据库

1. #### **MyISAm和InnoDB的区别**

   - InnoDB支持事务，MyISAm不支持

   - InnoDB支持外键，MyISAm不支持

   - InnoDB是聚簇索引，MyISAm是非聚簇索引

   - InnoDB支持行锁和表锁，MyISAm只支持表锁

   - InnoDB不支持全文索引，MyISAm支持

   - InnoDB支持自增和MVCC模式的读写，MyISAm不支持

2. #### mysql的事务特性，事务特性考靠什么保证

   （1）原子性：一个事务内的操作统一成功或失败，由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql

   （2）一致性：事务前后的数据总量不变，由其他三大特性共同保证，是事务的目的

   （3）隔离性：事务与事务之间相互不影响，由MVCC保证

   （4）持久性：事务一旦提交发生的改变不可逆，由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复

3. #### MySQl中的MVCC（多版本并发控制）是什么

   ​		MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。

   ​		实现原理由四个东西保证，他们是：

   ​		（1）undolog日志：记录了数据历史版本

   ​		（2）readView:事务进行快照读时产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见

   ​		（3）隐藏字段DB_TRC_ID： 最近修改记录的事务ID

   ​		（4）隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本

4. #### 事务的隔离级别

   在高并发情况下，并发事务会产生**读未提交、脏读、不可重复读、幻读**问题，这时需要用隔离级别来控制

   读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。

   读提交： 只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。

   可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。

   可串行化： 所有事务逐次执行，没有并发问题

   Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。

5. #### 快照读和当前读

​		快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照读

​		当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读

 6. #### MySQL有哪些索引

    **主键索引**：一张表只能有一个主键索引，主键索引列不能有空值和重复值

    **唯一索引**：唯一索引不能有相同值，但允许为空

    **普通索引**：允许出现重复值

    **组合索引**：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则

    **全文索引**：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎

 7. #### 聚簇索引和非聚簇索引的区别

    **聚簇索引**：将索引和值放在了一起，根据索引可以直接获取值，如果主键值很大的话，辅助索引也会变得很大

    **非聚簇索引**：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据

    他们都是b+数结构

 8. #### MySQL有哪些锁

    **基于粒度：**

    *表级锁：对整张表加锁，粒度大并发小

    *行级锁：对行加锁，粒度小并发大

    *间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读

    **基于属性：**

    *共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁

    *排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题

 9. #### MySQL的查询优化

    （1）分析sql语句，是否加载了不需要的数据列

    （2）分析sql执行计划，字段有没有索引，索引是否失效，是否用对索引

    （3）表中数据是否太大，是不是要分库分表

 10. #### 哪些情况索引会失效

     （1）where条件中有or，除非所有查询条件都有索引，否则失效

     （2）like查询用%开头，索引失效

     （3）索引列参与计算，索引失效

     （4）违背最左匹配原则，索引失效

     （5）索引字段发生类型转换，索引失效

     （6）mysql觉得全表扫描更快时（数据少），索引失效

 11. #### 内连接，左连接，右连接的区别

     1. 内连接 

        1. 等值连接：使用等于号查询结果中列出呗连接表中的所有列，包括重读列
        2. 不等值连接：在连接条件使用除了等号之外的符号进行连接
        3. 自然连接：使用等号，但是会删除连接表中的重复列

     2. 外连接

        1. 左连接：以左表为基准就行连接，如果在右表中没有左表对应的显示项，就将其设为null
        2. 右连接：以右表为基准就行连接，如果在左表中没有右表对应的显示项，就将其设为null
        3. 全连接：返回左表和右表中的所有行，如果没有各自对应的匹配，就均显示为null

     3. 交叉连接 cross join

        返回左表中的所有行，且左表中的每一行均与右表中的所有行组合，也成为笛卡尔积

## 六. Java Web




