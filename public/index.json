[{"categories":["个人网站建设"],"content":"一. 为网站添加图标，可以在标签页显示 利用 Favicon 为 Hugo 静态站点添加图标 - Bright’s Blog (ibrights.github.io) ","date":"2023-02-23","objectID":"/hugo-githubpages%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/:1:0","tags":["hugo","github"],"title":"hugo+GithubPages创建网站的相关问题","uri":"/hugo-githubpages%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["个人网站建设"],"content":"二. 修改网站中的各种图片——以LoveIt为例 post文章中的图片放在网站的根目录下static下 config.toml中的图片路径放在themes的你使用的主题的文件夹下的static下 ","date":"2023-02-23","objectID":"/hugo-githubpages%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/:2:0","tags":["hugo","github"],"title":"hugo+GithubPages创建网站的相关问题","uri":"/hugo-githubpages%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["个人网站建设"],"content":"三. 为网站添加域名 为Github page绑定自定义域名并实现https访问_yucicheung的博客-CSDN博客_github page https ","date":"2023-02-23","objectID":"/hugo-githubpages%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/:3:0","tags":["hugo","github"],"title":"hugo+GithubPages创建网站的相关问题","uri":"/hugo-githubpages%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["Java"],"content":"Java面试八股文 ","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:0:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"一. Java基础 Java语言有哪些特点 Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。 具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。 Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。 Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。 Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。 Java文件中可以有多个类吗（不包含内部类） 一个Java文件中可以有多个类，但是最多只能有一个被public修饰的类； 如果该文件中包含public修饰的类，则类的名称和Java文件的名称必须相同。 Java访问权限 Java语言中共有三种访问修饰符：public、private、protected； 在使用这些修饰符修饰目标时，一共可以形成四种访问权限，public、private、protected、default（不加任何修饰符）。 修饰成员变量/方法时： private：该成员可以被该类内部成员访问； default：该成员可以被该类内部成员访问，也可以被同一包下的其他类访问； protected：该成员可以被该类内部成员访问，也可以被同一包下的其他类访问，还可以被它的子类访问； public：该成员可以被任意类访问。 修饰类时： default：该类可以被同一包下的其他类访问； public： 该类可以被任意包下，任意类访问 Java数据类型 Java数据类型包括两大类：基本数据类型，引用数据类型。 基本数据类型有8个，可以分为4类：整数类型（byte/short/int/long）、浮点类型（float/double）、字符类型（char）、布尔类型（boolean）。除了布尔类型，其他都可以看作为数组类型，可以进行类型转换。 引用类型就是对一个对象的引用，根据引用对象的不同，可以分为数组、类、接口引用类型。实质上就是通过指针，指向堆中对象所持有的内存空间。 基本数据类型所占的内存空间 byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1； short：2字节（16位），数据范围是 -2^15 ~ 2^15-1； int：4字节（32位），数据范围是 -2^31 ~ 2^31-1； long：8字节（64位），数据范围是 -2^63 ~ 2^63-1； float：4字节（32位），数据范围是 -3.410^38 ~ 3.410^38； double：8字节（64位），数据范围是 -1.810^308 ~ 1.810^308； char：2字节（16位），数据范围是 \\u0000 ~ \\uffff； boolean：不同的JVM有不同的实现机制，没有固定的参数 Java内部类 成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性。 局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。 匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量。 静态内部类：类似类的静态成员变量。 Java为什么不支持多重继承 为了程序的结构能够更加清晰从而便于维护。假设 Java 语言支持多重继承，类 C 继承自类 A 和类 B，如果类 A 和 B 都有自定义的成员方法 f()，那么当代码中调用类 C 的 f() 会产生二义性。 Java 语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类 C 继承接口 A 与接口 B 时即使它们都有方法f()，也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义性。 多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。 Java代码块执行顺序 父类静态代码块（只执行一次） 子类静态代码块（只执行一次） 父类构造代码块 父类构造函数 子类构造代码块 子类构造函数 普通代码块 全局变量(成员变量)和局部变量 Java中没有全局变量，这是c语言中的概念，Java中对应的名称叫做成员变量。 成员变量 成员变量是在类的范围内定义的变量； 成员变量有默认初始值； 未被static修饰的成员变量也叫实例变量，存储于对象所在的堆内存当中，生命周期与对象相同； 被static修饰的成员变量也叫类变量，存储于方法区当中，生命周期与当前类相同 局部变量 局部变量是在方法内定义的变量； 局部变量没有默认初始值； 局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。 为什么要有包装类 ​ Java是面向对象的语言，设计理念就是“一切皆是对象”。但是8种基本数据类型却不属于对象，为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，叫做包装类。 自动装箱与自动拆箱是JDK1.5提供的功能。 自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型； 自动拆箱：可以把一个包装类型的数据直接赋值给对应额基本类型； 应用场景：例如某个方法的参数是包装类型，调用时我们所使用的数据却是基本类型的数据，这时可以不做任何处理，直接将这个基本类型的值传入给方法即可 面向对象的理解 什么是面向对象？ java将对象视为一种奇特的变量，它除了可以存储数据之外还可以对它自身进行操作。它能够直接反映现实生活中的事物，例如人、车、小鸟等，将其表示为程序中的对象。每个对象都具有各自的状态特征（也可以称为属性）及行为特征（方法），java就是通过对象之间行为的交互来解决问题的 面向对象和面向过程的区别？ 面向过程 优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。 缺点：不易维护、不易复用、不易扩展 面向对象 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点：性能比面向过程差 Java面向对象的三大特性？ 类具有三个特性：封装、继承和多态。 1、封装(Encapsulation) 封转是指属性私有化 根据需要提供setter和getter方法来访问属性 隐藏具体属性和实现细节，仅对外开放接口 控制程序中属性的访问级别 目的：增强数据安全性，不能让其他用户随意访问和修改数据，简化编程，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员 2、继承（Extend） 继承是指将多个相同的属性和方法提取出来，新建一个父类 java中一个类只能继承一个父类，且只能继承访问权限非private属性和方法 子类可以重写父类中的方法，命名与父类中同名的属性 目的：代码复用 3、多态 多态（Polymiorph）可以分为两种：设计时多态、运行时多态 **设计（编译）时多态：**即重载（Overload），是指java允许方法名相同而参数不同（返回值可以相同也可以不同），同一个类中允许存在一个或多个以上的同名函数，只要参数类型或参数个数不同即可 **运行时多态：**即重写（Override）必须是在继承体系中，子类重写父类方法，JVM运行时根据调用该方法的类型决定调用那个方法 目的：增加代码的灵活度 重载和重写的区别 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。 Object常用的方法 hashCode：通过对象计算出的散列码。用于 map 型或 equals 方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。 equals：判断两个对象是否一致。需保证 equals 方法相同对应的对象 hashCode 也相同。 toString: 用字符串表示该对象 clone:深拷贝一个对象 hashCode() 和 equals()的关系 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数 以“HashSet如何检查重复”为例子来说明为什么要有hashCode： 对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有 值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来 检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。 如果两个对象相等，那么hashcode一定相等，且equals()返回true，但是如果两个对象有相同的hashcode，两者不一定相等，hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashCode(),那","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:1:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"二. Spring Spring是什么 ​ Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转(IoC)和面向切面(AOP)。 ​ 简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 ","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:2:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"Spring常用注解 @Component：标注一个普通的Spring Bean类。 @Controller：标注一个控制器组件类。 @Service：标注一个业务层组件类。 @Repository：标注一个dao持久层组件类。 Spring用了哪些设计模式 BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式 Spring事务原理 ​ spring事务有编程式和声明式，我们一般使用声明式，在某个方法上增加@Transactional注解，这个方法中的sql会统一成功或失败。 原理是： ​ 当一个方法加上@Transactional注解，spring会基于这个类生成一个代理对象并将这个代理对象作为bean，当使用这个bean中的方法时，如果存在@Transactional注解，就会将事务自动提交设为false，然后执行方法，执行过程没有异常则提交，有异常则回滚、 Spring事务失效场景 （1）事务方法所在的类没有加载到容器中 （2）事务方法不是public类型 （3）同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效 （4）spring事务默认只回滚运行时异常，可以用rollbackfor属性设置 （5）业务自己捕获了异常，事务会认为程序正常秩序 Spring事务的隔离级别 default:默认级别，使用数据库自定义的隔离级别 其它四种隔离级别与mysql Spring事务的传播行为 （1）支持当前事务，如果不存在，则新启一个事务 （2）支持当前事务，如果不存在，则抛出异常 （3）支持当前事务，如果不存在，则以非事务方式执行 （4）不支持当前事务，创建一个新事物 （5）不支持当前事务，如果已存在事务就抛异常 （6）不支持当前事务，始终以非事务方式执行 Spring中IOC（控制反转）的理解 ​ IOC容器：实际上就是一个map（key，value），里面存着各种对象（在xml里配置的bean节点、@repository、@Service、@controller、@component），在项目启动的时候回读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里 ​ 这个时候map里面就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过ID注入（@autowired，@resource等注解，xml里bean结点内的ref属性，项目启动的时候就会读取xml节点ref属性，根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。 控制反转： 没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 引入IOC容器之后，对象A与对象B之间失去了失去了直接联系，当对象A运行到需要对象B的时候，IOC会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，不难看出：对象A获得依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒过来了，这句是“控制反转”这个名称的由来 全部对象的控制权全部上缴给第三方“IOC”容器，所以，IOC容器成了整个系统的关键核心，它气到了一种类似粘合剂的所用，把系统中的所有对象粘合在一起发挥作用，如果没有这个粘合剂，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成粘合剂的由来 依赖注入： 获得依赖对象的过程被反转了。控制被反转之后，获得依赖对象的过程由自身管理变成了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 如何实现一个IOC容器 1.配置文件，配置包扫描路径 2.递归包，扫描获取.class文件 3.反射、确定需要交给IOC管理的类 4.对需要注入的类进行依赖注入 配置文件中指定需要扫描的包路径 配置一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解 从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储 遍历这个Set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 遍历这个IOC容器,获取到每一个类的实例,判断里面是有否有依赖其它的类的实例,然后进行递归注入 Spring中AOP（面向切面）的理解 ​ 系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志，事务管理和信息安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。 ​ 当我们需要为分散的对象引入公共行为的时候，OOP显得无能为力。也就是说OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。 ​ 日志代码往往水平散布在所有对象层次中，而与它所散布到的随想的核心功能毫无关系。 ​ 在OOP设置中，它导致了大量代码的重复，而不利于各个模块的重用。 ​ AOP：将程序的交互业务逻辑（如安全、日志、事务），封装成一个切面，然后注入的到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外地做一些事情，在某个方法执行之后额外做一些事情。 SpringMVC工作原理 ​ SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器） 工作流程： （1）DispatchServerlet接收用户请求将请求发送给HandleMapping （2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet （3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler （4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view （5）DispatchServerlet根据view进行视图渲染，返回给用户 SpringMVC常用注解 @Controller 声明该类为SpringMVC中的Controller 控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中使用@Controller ，就无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。 @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式 @RequestMapping @RequestMapping的作用是建立请求URL和处理方法之间的对应关系 @RequestMapping可以作用在方法和类上 作用在类上：第一级的访问目录 作用在方法上：第二级的访问目录 @Autowired 作用：spring可以自动帮你把bean里面引用的对象的setter/getter方法省略，它会自动帮你set/get 正常情况下，你在userService里面要做一个userDao的setter/getter方法，但如果你用了@Autowired，你就不需要写getter/setter方法了，只需要在UserService的实现类中声明即可，之所以不用写，秘诀就在于java的“反射机制” @ResponseBody 作用：@ResponseBody注解通常使用在控制层的方法上，用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json、xml等，通过Response响应给客户端。假如是字符串则直接将字符串写到客户端；假如是一个对象，此时会将对象转化为json串然后写到客户端。这里需要注意的是，如果返回对象，按utf-8编码。如果返回String，页面可能出现乱码。因此在注解中我们可以","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:3:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"三. Redis redis为什么快 （1）完全基于内存操作，数据都存在内存中 （2）采用单线程，避免了不必要的上下文切换带来的性能问题，也不用考虑锁的问题 （3）基于非阻塞的io多路复用机制 （4）数据结构简单，对数据操作简单 redis持久化机制 （1）快照持久化RDB ​ redis的默认持久化机制，通过父进程fork一个子进程，子进程将redis的数据快照写入一个临时文件，等待持久化完毕后替换上一次的rdb文件。整个过程主进程不进行任何的io操作。持久化策略可以通过save配置单位时间内执行多少次操作触发持久化。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，缺点是可能会丢失两次持久化之间的数据 （2）追加持久化AOF ​ 以日志形式记录每一次的写入和删除操作，策略有每秒同步、每次操作同步、不同步，优点是数据完整性高，缺点是运行效率低，恢复时间长 redis如何实现key的过期删除 定期过期+惰性过期 定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。 惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。 redis数据类型 String 常用命令： set,get,decr,incr,mget等 Hash 常用命令： hget,hset,hgetall 等 List 常用命令： lpush,rpush,lpop,rpop,lrange 等 Set 常用命令： sadd,spop,smembers,sunion 等 SortSet 常用命令： zadd,zrange,zrem,zcard 等 redis缓存穿透如何解决 缓存穿透是指频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。 解决方案： （1）在接口上做基础校验，比如id\u003c=0就拦截 （2）缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致 （3）布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求 redis缓存击穿如何解决 缓存击穿是指一个key非常热点，key在某一瞬间失效，导致大量请求到达数据库 解决方案： （1）设置热点数据永不过期 （2）给缓存重建的业务加上互斥锁，缺点是性能低 redis缓存雪崩如何解决 缓存雪崩是指某一时间Key同时失效或redis宕机，导致大量请求到达数据库 解决方案： （1）搭建集群保证高可用 （2）进行数据预热，给不同的key设置随机的过期时间 （3）给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量 （4）给业务添加多级缓 redis分布式锁的实现原理 ​ 原理是使用setnx+setex命令来实现，但是会有一系列问题： （1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决 （2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作 （3）不可重入。可以使用Redision解决（实现机制类似AQS,计数） （4）redis集群下主节点宕机导致锁丢失。使用红锁解决 redis集群方案 (1)主从模式：个master节点，多个slave节点，master节点宕机slave自动变成主节点 (2)哨兵模式：在主从集群基础上添加哨兵节点或哨兵集群，用于监控master节点健康状态，通过投票机制选择slave成为主节点 (3)分片集群：主从模式和哨兵模式解决了并发读的问题，但没有解决并发写的问题，因此有了分片集群。分片集群有多个master节点并且不同master保存不同的数据，master之间通过ping相互监测健康状态。客户端请求任意一个节点都会转发到正确节点，因为每个master都被映射到0-16384个插槽上，集群的key是根据key的hash值与插槽绑定 redis集群主从同步原理 ​ 主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。 ​ 后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据 redis缓存一致性解决方案 ​ 更新数据库时把缓存给删除是最优方案，可以更大概率避免并发问题，但是依旧会有缓存删除失败的问题。可以使用分布式事务，或者在删除失败后把key发送到rabbitMQ中进行异步删除重试 ","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:4:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"四. 计算机网络 TCP协议 TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP协议的特点 面向连接 ​ 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 仅支持单播传输 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流 TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输 对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 拥有拥塞控制 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞 TCP三次握手连接过程 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 为什么需要三次握手 为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误 TCP四次握手断开连接过程 第一次握手 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次握手 B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次握手 B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 第四次握手 A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 UDP协议 UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 它有以下特点： 面向无连接 首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 2. 有单播，多播，广播的功能 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 UDP是面向报文的 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文 不可靠性 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。 再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 头部开销小，传输报文是高效的 TCP和UDP的区别 TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 对数据准确性要求高，速度可以相对较慢的，可以选用TCP ","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:5:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"四. 操作系统 ","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:6:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"五. 数据库 MyISAm和InnoDB的区别 InnoDB支持事务，MyISAm不支持 InnoDB支持外键，MyISAm不支持 InnoDB是聚簇索引，MyISAm是非聚簇索引 InnoDB支持行锁和表锁，MyISAm只支持表锁 InnoDB不支持全文索引，MyISAm支持 InnoDB支持自增和MVCC模式的读写，MyISAm不支持 mysql的事务特性，事务特性考靠什么保证 （1）原子性：一个事务内的操作统一成功或失败，由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql （2）一致性：事务前后的数据总量不变，由其他三大特性共同保证，是事务的目的 （3）隔离性：事务与事务之间相互不影响，由MVCC保证 （4）持久性：事务一旦提交发生的改变不可逆，由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复 MySQl中的MVCC（多版本并发控制）是什么 ​ MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。 ​ 实现原理由四个东西保证，他们是： ​ （1）undolog日志：记录了数据历史版本 ​ （2）readView:事务进行快照读时产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见 ​ （3）隐藏字段DB_TRC_ID： 最近修改记录的事务ID ​ （4）隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本 事务的隔离级别 在高并发情况下，并发事务会产生读未提交、脏读、不可重复读、幻读问题，这时需要用隔离级别来控制 读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。 读提交： 只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。 可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。 可串行化： 所有事务逐次执行，没有并发问题 Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。 快照读和当前读 ​ 快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照读 ​ 当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读 MySQL有哪些索引 主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值 唯一索引：唯一索引不能有相同值，但允许为空 普通索引：允许出现重复值 组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则 全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎 聚簇索引和非聚簇索引的区别 聚簇索引：将索引和值放在了一起，根据索引可以直接获取值，如果主键值很大的话，辅助索引也会变得很大 非聚簇索引：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据 他们都是b+数结构 MySQL有哪些锁 基于粒度： *表级锁：对整张表加锁，粒度大并发小 *行级锁：对行加锁，粒度小并发大 *间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读 基于属性： *共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁 *排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题 MySQL的查询优化 （1）分析sql语句，是否加载了不需要的数据列 （2）分析sql执行计划，字段有没有索引，索引是否失效，是否用对索引 （3）表中数据是否太大，是不是要分库分表 哪些情况索引会失效 （1）where条件中有or，除非所有查询条件都有索引，否则失效 （2）like查询用%开头，索引失效 （3）索引列参与计算，索引失效 （4）违背最左匹配原则，索引失效 （5）索引字段发生类型转换，索引失效 （6）mysql觉得全表扫描更快时（数据少），索引失效 内连接，左连接，右连接的区别 内连接 等值连接：使用等于号查询结果中列出呗连接表中的所有列，包括重读列 不等值连接：在连接条件使用除了等号之外的符号进行连接 自然连接：使用等号，但是会删除连接表中的重复列 外连接 左连接：以左表为基准就行连接，如果在右表中没有左表对应的显示项，就将其设为null 右连接：以右表为基准就行连接，如果在左表中没有右表对应的显示项，就将其设为null 全连接：返回左表和右表中的所有行，如果没有各自对应的匹配，就均显示为null 交叉连接 cross join 返回左表中的所有行，且左表中的每一行均与右表中的所有行组合，也成为笛卡尔积 ","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:7:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["Java"],"content":"六. Java Web ","date":"2023-02-22","objectID":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/:8:0","tags":["Java","面试","八股文"],"title":"Java面试八股文","uri":"/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["算法"],"content":"总结 时间复杂度 空间复杂度 是否每次遍历都能确定一个数的位置 适用 直接插入排序 O(n^2) 1 否 希尔排序 O(nlogn) 1 否 冒泡排序 O(n^2) 1 是 简单选择排序 O(n^2) 1 是 快速排序 O(nlogn) 1 是 归并排序 O(nlogn) n 堆排序 O(nlogn) 1 是 计数排序 O(n) k:k为n中最大最小值差 没有所谓循环 整数最大最小值差远远小于数组数量 ","date":"2023-02-22","objectID":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:0","tags":["算法","排序"],"title":"几种常用的排序算法总结","uri":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"1. 插入排序 1.直接插入排序 基本思量：每一步将一个待排序都数据插入到已经排好序的序列之中，知道所以都元素查完为止 ​ 算法实现： public void straightSort(int[] arr){ int n = arr.length; // 从1开始，因为arr[0]可以视作一个元素的有序数列，之后从1开始到序列视为无序数列 for(int i = 1; i \u003c n; i++){ int temp = arr[i]; // 从已排序的序列的最后进行比较，找到合适的位置 int j = i - 1; while(j \u003e= 0 \u0026\u0026 arr[j] \u003e temp){ arr[j+1] = arr[j]; j--; } arr[j+1] = temp; } } ​ 时间复杂度：O(n^2) ​ 空间复杂度：T(1) 2. 希尔排序 基本思想：将序列按照下标的一定增量分组，每个组中进行直接插入排序，然后增量减半，再再组内进行直接插入排序，。。。，直到增量减小为1时排序完成 ​ 算法实现: public void shellSort(int[] arr){ int n = arr.length; for(int gap = n / 2; gap \u003e= 1; gap/=2){ for(int i = 0; i \u003c gap; i++){ // 进行插入排序，每个元素的下一个元素都是i+gap for(int j = i + gap; j \u003c n; j+=gap){ int temp = arr[j]; int k = j-gap; while(k\u003e=0 \u0026\u0026 arr[k] \u003e temp){ arr[k+gap] = arr[k]; k-=gap; } arr[k+gap]= temp; } } } } ​ 时间复杂度：O(n*log2n) ​ 空间复杂度：1 ","date":"2023-02-22","objectID":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:1:0","tags":["算法","排序"],"title":"几种常用的排序算法总结","uri":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"2.冒泡排序 1.冒泡排序 基本思想：一种交换排序，一次只能将一个位置上的数字归位，第一次将[0, …. n-1]作为未排序数组，从0开始，如果num[i] \u003e num[i+1], 那么交换两个数组，直到交换num[n-2]和num[n-1], 确定了num[n-1]的数子为[0,….,n-1]上最大的数字，之后确定[0, …., n-2]上的最大数字交换至num[n-2],直到[0,1] 算法实现 public void bubbleSort(int[] arr){ int n = arr.length; for(int i = n-1; i \u003e= 1; i--){ for(int j = 0; j \u003c i; j++){ if(arr[j] \u003e arr[j+1]){ int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } ​ 时间复杂度：O(n^2) ​ 空间复杂的：O(1) 2.简单选择排序 基本思想：是一种冒泡排序，但是每次只交换为排序数组中最大的那个数和末尾的数，而不是发现顺序不对就交换，这也是思路最直接到排序方法 算法实现 public void selectSort(int[] arr){ int n = arr.length; for(int i = n-1; i \u003c= 1; i--){ int max = arr[i]; int max_i = i; for(int j = 0; j \u003c i; j++){ if(arr[j] \u003e max){ max = arr[j]; max_i = j; } } arr[max_i] = arr[i]; arr[i] = max; } } ​ 时间复杂度：O(n^2) ​ 空间复杂度：O(1) ","date":"2023-02-22","objectID":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:2:0","tags":["算法","排序"],"title":"几种常用的排序算法总结","uri":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"3.分治法排序 1.快速排序 基本思想：从待排序序列中任选一个元素，作为中间元素，作为pivot，将所有比pivot小的元素移动到它的左边，比pivot大的元素放在右边，pivot左右两边的子序列，重复前面的步骤，知道子序列不可再分 算法实现 public void quickSort(int[] arr, int begin, int end){ if(begin \u003e= end){ return; } int mid = sort(arr, begin, end); quickSort(arr, begin, mid-1); quickSort(arr, mid + 1, end); } private void sort(int[] arr, int begin, int end){ int p = begin; int q = end; int pivot = arr[p]; while(p \u003c q){ // 从右往左找到第一个不大于pivot的数 while(p \u003c q \u0026\u0026 arr[q] \u003e pivot){ q--; } if(p \u003c q){ arr[p] = arr[q]; p++; } // 从左往右找到第一个不小于pivot的数 while(p \u003c q \u0026\u0026 arr[p] \u003c pivot){ p++; } if(p \u003c q){ arr[q] = arr[p]; q--; } } arr[p] = pivot; return p; } ​ 时间复杂度：O(nlogn) ​ 空间复杂度：T(1) ","date":"2023-02-22","objectID":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:3:0","tags":["算法","排序"],"title":"几种常用的排序算法总结","uri":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"4.堆排序 基本思想:构建一个堆，保证堆顶的数字是最大值（最小值） 算法实现 public class HeapSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i \u003e 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0, len); } return arr; } private void buildMaxHeap(int[] arr, int len) { for (int i = (int) Math.floor(len / 2); i \u003e= 0; i--) { heapify(arr, i, len); } } private void heapify(int[] arr, int i, int len) { int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left \u003c len \u0026\u0026 arr[left] \u003e arr[largest]) { largest = left; } if (right \u003c len \u0026\u0026 arr[right] \u003e arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest, len); } } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } ​ 时间复杂度：O(nlogn) ​ 空间复杂度：T(1) ","date":"2023-02-22","objectID":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:4:0","tags":["算法","排序"],"title":"几种常用的排序算法总结","uri":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"5.计数排序 算法思路：统计整数序列中，每个数字出现的次数 步骤：1. 计算整数序列中的最大最小值max和min ​ 2.新建序列 int[] counts = new int[max - min + 1]，统计每个数字出现的次数 ​ 3.读取counts重新排序 适用于：1. 整数序列 2. max - min + 1« n(序列长度) 算法实现 public void sort(int[] arr){ int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(int num : arr){ min = Math.min(num, min); max = Math.max(num, max); } int[] counts = new int[max - min + 1]; int index = 0 for(int i = 0; i \u003c counts.length; i++){ while(counts[i] \u003e 0){ arr[index++] = min + i; counts[i]--; } } } ​ 时间复杂度：O(n) ​ 空间复杂度：O(k) k = max - min + 1 ","date":"2023-02-22","objectID":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:5:0","tags":["算法","排序"],"title":"几种常用的排序算法总结","uri":"/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["github"],"content":"一. 什么是GitHub ​ github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。 详细的参考文档，可以查阅：易百教程的文档 ","date":"2023-02-19","objectID":"/github%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["github"],"title":"github使用教程","uri":"/github%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["github"],"content":"二. 注册GitHub账户，以及创建仓库 注册GitHub账户 登录GitHub的官网地址：(https://github.com/) 创建远程仓库 Create a New Repository，填好名称后Create，之后会出现一些仓库的配置信息 本地GitHub安装 下载 git的Windows版本 Git for Windows 之后，安装即可 本地仓库创建 （1）首先在本地创建ssh key ssh-keygen -t rsa -C \"your_email@youremail.com\" ​ your_email@youremail.com 是你在注册GitHub时所用的邮箱，之后会要求确认路径和输入 密码，如果我们按照默认选项的话，会生成一个id_rsa.pub （2）复制id_rsa.pub中的内容到GitHub中 SSH Keys中 ​ github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便 填，粘贴在你电脑上生成的key。 ​ git三部分 ​ 验证是否成功： ssh -T git@github.com ​ 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 （3）设置username和email git config --global user.name \"your name\" git config --global user.email \"your_email@youremail.com\" git config --global --list # 查看是否设置成功 （4）本地设置仓库 ​ 在本地设置仓库有两种办法： ​ 一种是将已有的仓库克隆下来； ​ 一种是将现有的本地仓库链接并上传 克隆已有的仓库： ​ 如果是克隆本地的仓库 git clone /path/to/repository ​ 如果是远程服务器的仓库 git clone username@host:/path/to/repository 上传现有的本地仓库： ​ 如果现在的文件夹还不是git，需要在要上传的文件下执行： git init ​ 然后，链接到某个远程服务器 git remote add origin \u003cserver\u003e ","date":"2023-02-19","objectID":"/github%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["github"],"title":"github使用教程","uri":"/github%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["github"],"content":"三. GitHub工作流 ​ git的本地维护由三部分组成：第一个是你的工作目录——实际持有文件；第二个是缓存区(Index)——临时保存改动；最后是HEAD——指向最后一次提交的结果 git三部分 将更改保存至缓存区 git add file_name # 提交单个文件的修改 或者 git add . # 提交所有文件的修改 提交修改到HEAD git commit -m \"代码提交信息\" 注意：此时，改动已经提交到本地的HEAD，但是还没有同步到远程仓库 推送改动到远程仓库 如果此时还没有克隆现有仓库，需要链接某个远程服务器： git remote add origin \u003cserver\u003e # 例子：git remote add origin git@github.com:liangyi0506/liangyi0506.github.io.git 现在，可以将修改推送到远程仓库了： git push -u origin main # git push -u \u003c指定远程主机名\u003e \u003c本地分支名\u003e:\u003c远程分支名\u003e 可以把main换成任何你想要推送的任何分支 注意：如果不修改 push 后面的参数的话，以后不需要重复添加这些参数 参数： ​ -u ：指定默认主机，这样后面就可以不加任何参数使用git push ","date":"2023-02-19","objectID":"/github%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","tags":["github"],"title":"github使用教程","uri":"/github%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["个人网站建设"],"content":"一. 为什么要创建自己的个人博客网站 ​ 我们在进行学习的时候，尤其是在学习新的知识的时候，要想牢固掌握，最好的办法就是将新学习的。 ​ 知识向别人讲述，但是这个倾听者不好找，学习写博客同样是一种讲述的办法，同时也是将自己的知识进行收纳整理的一个过程。 ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"二. 为什么使用hugo+GitHub Pages hugo是一款可以方便生成可展示静态网页的工具，方便了不擅长前端编码的同学 在hugo下可以舒服地使用markdown进行博客文章页面的书写 我们需要一个展示的平台——一个服务器来存放我们的文章，CSDN这类的国内平台真的是越用越气人， 而且不支持个性化定制，GithubPages技术已经很成熟，而且参考资料众多 ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"三. 如何使用hugo+Github Pages 创建自己的博客 ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"（一）下载并安装hugo 1. 确认自己的安装环境 ​ 我这里是windows11，使用的是powershell7作为部署工具，这里可以参考 ​ https://gohugo.io/installation/windows/ ​ 我使用了chocolatey作为下载工具， ​ 在powershell7的管理员模式下下安装chocolatey的命令如下 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 2. 下载hugo的命令如下 choco install hugo-extended ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:1","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"（二）使用hugo创建自己的站点 1. 使用powershell打开自己想要创建的站点的文件夹路径 cd 自己想要创建的站点的文件夹路径 2. 创建自己的站点 hugo new_site ​ 这时候你会发现文件夹下多了一个文件夹叫new_site, 这就是我们接下来要编辑的hugo项目 ​ 接下来进入我们的项目 cd new_site ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:2","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"（三）挑选自己喜欢的主题，以LoveIt为例 1. 打开hugo的主题网站，网址如下 ​ https://themes.gohugo.io/ 2. 我选择了LoveIt作为主题，网址如下 ​ https://hugoloveit.com/ ​ 这个主题有详细的模块，而且提供了丰富的参考文档教你如何使用，并且支持中文 3.下载LoveIt主题 ​ 在new_site的主目录下，运行 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ​ 这样主题就会下载到themes文件夹下面 ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:3","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"（四）生成自己的第一篇文章 1. 使用如下的命令创建自己的第一篇文章 hugo new posts/first_post.md ​ **注意：**使用编辑器打开就会发下，使用这种方式创建的markdown文件，中draft参数是true，需要把他变成false，或者使用hugo -D / –buildDrafts serve 才能显示 2. 在本地启动站点 hugo serve ​ 登录 http://localhost:1313 ​ 就可以看到启动的网站 ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:4","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"（五）将站点部署到GitHub上 1. 在你的GitHub账户中创建一个库，命名为 github_user_name.github.io 2. 首先生成我们可以公开展示的文件夹，也就是需要上传到github上的文件夹public，执行 hugo --theme=LoveIt --baseUrl=\"https://liangyi0506.github.io/\" ​ 这样你会发下在网站的主目录下生成了一个public文件夹，这就是我们用来展示的文件夹，也是需要 上传到GitHub的文件夹 3. 之后，执行基本的git命令将public下文件上传到我们刚刚创建的库中 cd public git init // 初始化本地仓库 git add . // 添加文件到本地 git commit -m \"fist commit\" // 添加文件描述信息 git remote add origin 远程仓库地址 // 链接远程仓库 git pull origin main // 把本地仓库的变化链接到远程仓库 git push -u origin main // 把本地仓库的文件推送到远程仓库 ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["个人网站建设"],"content":"（六）登录我们的博客地址 ​ 登录 ​ liangyi0506.github.io ​ 即可, 这样任何人就都能访问你的网页 ","date":"2023-02-18","objectID":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:0","tags":["hugo","github"],"title":"Windows下使用hugo+github pages 创建自己的个人博客","uri":"/%E4%BD%BF%E7%94%A8hugo-githubpages%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]